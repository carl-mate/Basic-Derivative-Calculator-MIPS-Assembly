.data
input: .space 256
power: .space 256
coeff: .space 256
if_1_invalid_prompt: .asciiz	"Invalid character after integer."
if_2_invalid_prompt: .asciiz	"Invalid character after x."
if_3_invalid_prompt: .asciiz	"Invalid character after ^."
if_4_invalid_prompt: .asciiz	"Invalid character after +."
if_5_invalid_prompt: .asciiz	"Invalid character after -."
power_1_prompt: .asciiz		"x"
power_n_prompt: .asciiz		"x^"
plus: 		.asciiz		"+"


.text
main:
	li	$v0, 8			# Ask the user for the string they want to reverse
	li	$a1, 256		# Only 256 chars/bytes allowed
	la	$a0, input		# We'll store it in 'input'
	syscall
	
	li	$t0, 0			# counter
	li 	$t2, 0			# x_counter
	li	$t3, 1			# negative_check
	li	$t4, 0			# number
	li	$t5, 0			# power_check
	#li	$t6, 1			# validInput
	li      $s0, 0                  # powerFoundNonzero
	li      $s1, 0                  # coeffFoundNonzero
	li      $s2, 0                  # sum
	
	read_input_loop:
		lb $t1, input($t0)
		#If null, then exit
		beq	$t1, '\n', calculate_derivative		
		#if(input >= '0' && input <= '9')
		beq	$t1, '0', if_1
		beq 	$t1, '1', if_1
		beq 	$t1, '2', if_1
		beq 	$t1, '3', if_1
		beq 	$t1, '4', if_1
		beq 	$t1, '5', if_1
		beq 	$t1, '6', if_1
		beq 	$t1, '7', if_1
		beq 	$t1, '8', if_1
		beq 	$t1, '9', if_1
		#if(input == 'x')
		beq	$t1, 'x', if_2
		#if(input == '^')
		beq	$t1, '^', if_3
		#if(input == '+')
		beq	$t1, '+', if_4
		#if(input == '-')
		beq	$t1, '-', if_5
		#if(input != '\n') i.e., this character must be something else 
		bne	$t1, '\n', read_input_exit
	next:
		li	$t8, 0			# temp index
		addi	$t8, $t0, 1		# $t8 <- counter + 1 to get next element
		lb 	$t9, input($t8)		# get next element
		beq	$t9, '\n', next_power_check
		
		j	increment
    	next_power_check:
    		bne	$t5, 1, next_set_power_to_one
    		# save_power
		mul 	$t7, $t4, $t3 		# $t7 <- number * negative_check
		sb 	$t7, power($t2)
		li	$t4, 0			# number
		li	$t3, 1			# negative_check
		li	$t5, 0			# power_check
		
    		j	increment
    	next_set_power_to_one:
    		# power[x_counter] = 1
		li 	$t7, 1 		# $t7 <- 1
		sb 	$t7, power($t2)
		
		j	increment
    	increment:
    		#increment
   		addi 	$t0, $t0, 1
    		j	read_input_loop
		
read_input_exit:
	li	$v0, 10			# exit()
	syscall
	
############################################################################## if_1 START BLOCK	
	if_1:
		li	$t8, 0			# temp index
		addi	$t8, $t0, 1		# $t8 <- counter + 1 to get next element
		lb 	$t9, input($t8)		# get next element
		
		beq	$t9, 'x', if_1_valid
		beq 	$t9, '+', if_1_valid
		beq 	$t9, '-', if_1_valid
		beq 	$t9, '0', if_1_valid
		beq 	$t9, '1', if_1_valid
		beq 	$t9, '2', if_1_valid
		beq 	$t9, '3', if_1_valid
		beq 	$t9, '4', if_1_valid
		beq 	$t9, '5', if_1_valid
		beq 	$t9, '6', if_1_valid
		beq 	$t9, '7', if_1_valid
		beq 	$t9, '8', if_1_valid
		beq 	$t9, '9', if_1_valid
		beq 	$t9, '\n' if_1_valid
		j	if_1_invalid
	if_1_valid:
		mul	$t4, $t4, 10		# number = number * 10
		lb	$t8, input($t0)
		sub	$t8, $t8, '0'		# $t8 <- input[counter] - '0'
		add	$t4, $t4, $t8		# number = number + input
		j	next	
	if_1_invalid:
		li $v0, 4
		la $a0, if_1_invalid_prompt
		syscall
		j	read_input_exit
############################################################################## if_1 END BLOCK

############################################################################## if_2 START BLOCK
	if_2:	
		li	$t8, 0			# temp index
		addi	$t8, $t0, 1		# $t8 <- counter + 1 to get next element
		lb 	$t9, input($t8)		# get next element
		beq 	$t9, 'x', if_2_valid
		beq 	$t9, '+', if_2_valid
		beq 	$t9, '-', if_2_valid
		beq 	$t9, '^', if_2_valid
		beq 	$t9, '\n', if_2_valid
		j	if_2_invalid
	if_2_valid:
		blt	$t0, 1, if_2.1_invalid
		li	$t8, 0			# temp index
		sub	$t8, $t0, 1		# $t8 <- counter - 1 to get previous element
		lb 	$t9, input($t8)		# get previous element
		blt	$t9, '0', if_2.1_invalid
		bgt	$t9, '9', if_2.1_invalid
		j	if_2.1_valid
	if_2.1_valid:
		# save_coeff
		mul 	$t7, $t4, $t3 		# $t7 <- number * negative_check
		sb 	$t7, coeff($t2)
		li	$t4, 0			# number
		li	$t3, 1			# negative_check
		j	next
	if_2.1_invalid:
		# set number = 1
		li	$t4, 1
		# save_coeff
		mul 	$t7, $t4, $t3 		# $t7 <- number * negative_check
		sb 	$t7, coeff($t2)
		li	$t4, 0			# number
		li	$t3, 1			# negative_check
		j	next
	if_2_invalid:
		li $v0, 4
		la $a0, if_2_invalid_prompt
		syscall
		j	read_input_exit
		
############################################################################## if_2 END BLOCK

############################################################################## if_3 START BLOCK
	if_3:
		li	$t8, 0			# temp index
		addi	$t8, $t0, 1		# $t8 <- counter + 1 to get next element
		lb 	$t9, input($t8)		# get next element
		beq 	$t9, '0', if_3_valid
		beq 	$t9, '1', if_3_valid
		beq 	$t9, '2', if_3_valid
		beq 	$t9, '3', if_3_valid
		beq 	$t9, '4', if_3_valid
		beq 	$t9, '5', if_3_valid
		beq 	$t9, '6', if_3_valid
		beq 	$t9, '7', if_3_valid
		beq 	$t9, '8', if_3_valid
		beq 	$t9, '9', if_3_valid
		beq 	$t9, '-', if_3_valid
		j	if_3_invalid
	if_3_valid:
		# set power_check = 1
		li	$t5, 1
		
		li	$t8, 0			# temp index
		addi	$t8, $t0, 1		# $t8 <- counter + 1 to get next element
		lb 	$t9, input($t8)		# get next element
		bne	$t9, '-', next
		# set negative_check = -1
		# set counter = counter + 1
		li	$t3, -1
		addi	$t0, $t0, 1
		j	next						
	if_3_invalid:
		li $v0, 4
		la $a0, if_3_invalid_prompt
		syscall
		j	read_input_exit
############################################################################## if_3 END BLOCK

############################################################################## if_4 START BLOCK
	if_4:
		li	$t8, 0			# temp index
		addi	$t8, $t0, 1		# $t8 <- counter + 1 to get next element
		lb 	$t9, input($t8)		# get next element
		beq 	$t9, '0', if_4_valid
		beq 	$t9, '1', if_4_valid
		beq 	$t9, '2', if_4_valid
		beq 	$t9, '3', if_4_valid
		beq 	$t9, '4', if_4_valid
		beq 	$t9, '5', if_4_valid
		beq 	$t9, '6', if_4_valid
		beq 	$t9, '7', if_4_valid
		beq 	$t9, '8', if_4_valid
		beq 	$t9, '9', if_4_valid
		beq 	$t9, 'x', if_4_valid
		j	if_4_invalid
	if_4_valid:
		beq	$t5, 1, if_4.1_valid
		# power[x_counter] = 1
		li 	$t7, 1 		# $t7 <- 1
		sb 	$t7, power($t2)
		addi 	$t2, $t2, 1		# x_counter
		j	next
	if_4.1_valid:
		# save_power
		mul 	$t7, $t4, $t3 		# $t7 <- number * negative_check
		sb 	$t7, power($t2)
		li	$t4, 0			# number
		li	$t3, 1			# negative_check
		li	$t5, 0			# power_check
		addi 	$t2, $t2, 1		# x_counter
		j	next
	if_4_invalid:
		li $v0, 4
		la $a0, if_4_invalid_prompt
		syscall
		
		j	read_input_exit
############################################################################## if_4 END BLOCK

############################################################################## if_5 START BLOCK
	if_5:
		li	$t8, 0			# temp index
		addi	$t8, $t0, 1		# $t8 <- counter + 1 to get next element
		lb 	$t9, input($t8)		# get next element
		beq 	$t9, '0', if_5_valid
		beq 	$t9, '1', if_5_valid
		beq 	$t9, '2', if_5_valid
		beq 	$t9, '3', if_5_valid
		beq 	$t9, '4', if_5_valid
		beq 	$t9, '5', if_5_valid
		beq 	$t9, '6', if_5_valid
		beq 	$t9, '7', if_5_valid
		beq 	$t9, '8', if_5_valid
		beq 	$t9, '9', if_5_valid
		beq 	$t9, 'x', if_5_valid
		j	if_5_invalid
	if_5_valid:
		beq	$t5, 1, if_5.1_valid
		# power[x_counter] = 1
		li 	$t7, 1 		# $t7 <- 1
		sb 	$t7, power($t2)
		addi 	$t2, $t2, 1		# x_counter
		li	$t3, -1			# negative_check
		j	next
	if_5.1_valid:
		# save_power
		mul 	$t7, $t4, $t3 		# $t7 <- number * negative_check
		sb 	$t7, power($t2)
		li	$t4, 0			# number
		li	$t3, 1			# negative_check
		li	$t5, 0			# power_check
		addi 	$t2, $t2, 1		# x_counter
		li	$t3, -1			# negative_check
		j	next
	if_5_invalid:
		li $v0, 4
		la $a0, if_5_invalid_prompt
		syscall
		j	read_input_exit
############################################################################## if_5 END BLOCK

calculate_derivative:
	li	$t0, 0
	
	loop_1:
		bgt	$t0, $t2, end_loop_1
		lb 	$t3, coeff($t0)		# $t3 <- coeff[counter]
		lb	$t4, power($t0)		# $t4 <- power[counter]
		
		mul	$t5, $t3, $t4		# $t5 <- coeff[counter] * power[counter]
		sb	$t5, coeff($t0)		# coeff[counter] = coeff[counter] * power[counter]
		
		sub	$t6, $t4, 1		# $t6 <- power[counter] - 1
		sb	$t6, power($t0)
		
		addi	$t0, $t0, 1
		
		j	loop_1
		
	end_loop_1:
		li	$t0, 0
		j	loop_2
		
	loop_2:
		bgt	$t0, $t2, end_loop_2
		lb	$t3, power($t0)		# $t3 <- power[counter]
		beq	$t3, 0, increment_loop_2
		li	$s0, 1
		j	print_output
		
	end_loop_2:
		li	$t0, 0
		beq	$s0, 0, add_coeffs
		j	print_output
		
	increment_loop_2:
		addi	$t0, $t0, 1
		j	loop_2
	
	add_coeffs:
		bgt	$t0, $t2, end_add_coeffs
		lb	$t3, coeff($t0)		# $t3 <- coeff[counter]
		add	$s2, $s2, $t3		# $s2 <- sum + coeff[counter]
		addi	$t0, $t0, 1
		j	add_coeffs
	end_add_coeffs:
		j	print_output

print_output:
	bne	$s0, 1, output_sum
	li	$t0, 0
	
	print_output_loop:
		
		bgt	$t0, $t2, break_loop
		lb	$t1, coeff($t0)
		bnez	$t1, coeff_found_nonzero_1
		addi	$t1, $t1, 1
		ble	$t0, $t2, continue_print_output_loop
		bne	$s1, 0, break_loop
		li	$v0, 1
		li	$a0, 0
		syscall
		j	break_loop
	coeff_found_nonzero_1:
		li	$s1, 1
		lb	$t1, power($t0)
		beq	$t1, 0, power_0
		beq	$t1, 1, power_1
		j	power_n
	power_0:
		lb	$t1, coeff($t0)
		li	$v0, 1
		move	$a0, $t1
		syscall
		j	check_plus
	power_1:
		lb	$t1, coeff($t0)
		li	$v0, 1
		move	$a0, $t1
		syscall
		
		li	$v0, 4
		la	$a0, power_1_prompt
		syscall
		j	check_plus
	power_n:
		lb	$t1, coeff($t0)
		lb	$t3, power($t0)
		
		li	$v0, 1
		move	$a0, $t1
		syscall
		
		li	$v0, 4
		la	$a0, power_n_prompt
		syscall
		
		li	$v0, 1
		move	$a0, $t3
		syscall
		
		j	check_plus
	check_plus:
		li	$t8, 0			# temp index
		addi	$t8, $t0, 1		# $t8 <- counter + 1 to get next element
		lb 	$t9, coeff($t8)		# get next element
		ble	$t9, 0, inc_print_output_loop
		bge	$t0, $t2, inc_print_output_loop
		li	$v0, 4
		la	$a0, plus
		syscall
		j	inc_print_output_loop
	coeff_found_nonzero_0:
		bne	$s1, 0, break_loop
	break_loop:
		li	$v0, 10
		syscall
	inc_print_output_loop:
		addi	$t0, $t0, 1
		j	print_output_loop
	continue_print_output_loop:
		j	print_output_loop
	
	output_sum:
		addi 	$v0, $zero, 1
		move	$a0, $s2
		syscall
		
		li	$v0, 10
		syscall
		
	
		